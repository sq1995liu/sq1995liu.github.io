(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{1081:function(i,s,v){"use strict";v.r(s);var _=v(21),e=Object(_.a)({},(function(){var i=this,s=i.$createElement,_=i._self._c||s;return _("ContentSlotsDistributor",{attrs:{"slot-key":i.$parent.slotKey}},[_("h1",{attrs:{id:"_01-基于redis搭建高可用集群"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_01-基于redis搭建高可用集群"}},[i._v("#")]),i._v(" 01.基于Redis搭建高可用集群")]),i._v(" "),_("blockquote",[_("p",[i._v("实现可靠缓存服务即热点数据保存。redis持久化，集群，哨兵，主从，缓存击穿，热点key。")])]),i._v(" "),_("ul",[_("li",[i._v("redis有哪几种集群\n"),_("ul",[_("li",[i._v("主从模式")]),i._v(" "),_("li",[i._v("哨兵模式")]),i._v(" "),_("li",[i._v("codis")])])]),i._v(" "),_("li",[i._v("redis主动同步机制\n"),_("ul",[_("li",[_("strong",[i._v("RDB")]),i._v(" "),_("ul",[_("li",[i._v("全量同步：从服务器把有的数据全部丢弃，让主服务把所有数据全部发给他")])])]),i._v(" "),_("li",[_("strong",[i._v("AOF")]),i._v(" "),_("ul",[_("li",[i._v("增量同步：主服务器只发送从服务器缺少的数据")])])]),i._v(" "),_("li",[_("strong",[i._v("redis主从同步应该采用哪种方式")]),i._v(" "),_("ul",[_("li",[i._v("主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。")]),i._v(" "),_("li",[i._v("当然，如果有需要，slave 在任何时候都可以发起全量同步。")]),i._v(" "),_("li",[i._v("redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。")])])])])]),i._v(" "),_("li",[i._v("redis主从\n"),_("ul",[_("li",[i._v("写主库、读从库，减轻服务器读压力")]),i._v(" "),_("li",[i._v("缺点：但是redis主从不能自动切换master，所以master如果挂掉了，整个集群都不可以写入啦")])])])]),i._v(" "),_("p",[_("img",{attrs:{src:v(731),alt:"1582594403768"}})]),i._v(" "),_("ul",[_("li",[_("p",[i._v("哨兵模式如何解决主从问题")]),i._v(" "),_("ul",[_("li",[i._v("当用Redis做主从方案时，假如master宕机，Redis本身无法自动进行主备切换")]),i._v(" "),_("li",[i._v("而Redis-sentinel本身也是一个独立运行的进程，它能监控多个master-slave集群，发现master宕机后能进行自动切换。")])])]),i._v(" "),_("li",[_("p",[_("strong",[i._v("sentinel原理")])]),i._v(" "),_("ul",[_("li",[i._v("sentinel负责持续监控主节点的健康，当主节挂掉时，自动选择一个最优的从节点切换成主节点")]),i._v(" "),_("li",[i._v("从节点来连接集群时会首先连接sentinel，通过sentinel来查询主节点的地址")]),i._v(" "),_("li",[i._v("当主节点发生故障时，sentinel会将最新的主节点地址告诉客户端，可以实现无需重启自动切换redis")])]),i._v(" "),_("p",[_("img",{attrs:{src:v(732),alt:"1582596207680"}})]),i._v(" "),_("ul",[_("li",[i._v("sentinel缺点\n"),_("ul",[_("li",[i._v("redis的slave和master数据时完全一样的，但是有个问题，redis数据时存储在内存中")]),i._v(" "),_("li",[i._v("内存空间有限，所以哨兵模式不能处理大的数据量")])])])])]),i._v(" "),_("li",[_("p",[i._v("codis")]),i._v(" "),_("ul",[_("li",[_("p",[_("strong",[i._v("为什么会出现codis")])]),i._v(" "),_("ul",[_("li",[i._v("在大数据高并发场景下，单个redis实例往往会无法应对")]),i._v(" "),_("li",[i._v("首先redis内存不易过大，内存太大会导致rdb文件过大，导致主从同步时间过长")]),i._v(" "),_("li",[i._v("其次在CPU利用率中上，单个redis实例只能利用单核，数据量太大，压力就会特别")])])]),i._v(" "),_("li",[_("p",[_("strong",[i._v("codis部署方案")])]),i._v(" "),_("ul",[_("li",[i._v("单个codis代理支撑的QPS比较有限，通过启动多个codis代理可以显著增加整体QPS")]),i._v(" "),_("li",[i._v("多codis还能起到容灾功能，挂掉一个codis代理还有很多codis代理可以继续服务")])])])])])]),i._v(" "),_("p",[_("img",{staticStyle:{width:"600px","margin-left":"10px"},attrs:{src:v(733)}})]),i._v(" "),_("ul",[_("li",[_("strong",[i._v("codis分片的原理")]),i._v(" "),_("ul",[_("li",[i._v("codis负责将特定key转发到特定redis实例，codis默认将所有key划分为1024个槽位")]),i._v(" "),_("li",[i._v("首先会对客户端传来的key进行crc32计算hash值，然后将hash后的整数值对1024进行取模，这个余数就是对应的key槽")]),i._v(" "),_("li",[i._v("每个槽位都会唯一映射到后面的多个redis实例之一，codis会在内存中维护槽位和redis实例的映射关系")]),i._v(" "),_("li",[i._v("这样有了上面key对应的槽位，那么它应该转发到那个redis实例就很明确了")]),i._v(" "),_("li",[i._v("槽位数量默认是1024，如果集群中节点较多，建议将这个数值大一些，比如2048,4096")])])])]),i._v(" "),_("p",[_("img",{attrs:{src:v(734),alt:"1582599097281"}})])])}),[],!1,null,null,null);s.default=e.exports},731:function(i,s,v){i.exports=v.p+"assets/img/1582594403768.ace2dd20.png"},732:function(i,s,v){i.exports=v.p+"assets/img/1582596207680.a0b89436.png"},733:function(i,s,v){i.exports=v.p+"assets/img/image-20210113154233462.031bfe8e.png"},734:function(i,s,v){i.exports=v.p+"assets/img/1582599097281.49f68012.png"}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[80],{334:function(e,t,v){e.exports=v.p+"assets/img/image-20201215165654516.41cec4c0.png"},619:function(e,t,v){e.exports=v.p+"assets/img/image-20201215175845710.4a59b03f.png"},985:function(e,t,v){"use strict";v.r(t);var _=v(21),o=Object(_.a)({},(function(){var e=this,t=e.$createElement,_=e._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h2",{attrs:{id:"_01-k8s工作原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_01-k8s工作原理"}},[e._v("#")]),e._v(" 01.K8S工作原理")]),e._v(" "),_("ul",[_("li",[e._v("1.我们通过"),_("code",[e._v("kubectl")]),e._v("向"),_("code",[e._v("k8s Master")]),e._v("发出指令。")]),e._v(" "),_("li",[e._v("2.kubernetes Master主要是提供"),_("code",[e._v("API Server、Scheduler、Controller")]),e._v("组件，"),_("code",[e._v("接收kubectl的命令")])]),e._v(" "),_("li",[e._v("3.kubernetes Master主从Node节点"),_("code",[e._v("获取Node的资源信息")]),e._v("，并"),_("code",[e._v("发出调度任务")]),e._v("。")]),e._v(" "),_("li",[e._v("4.Node节点提供"),_("code",[e._v("kubelet、kube-proxy")]),e._v("，每个node节点都安装docker，是实际的执行者。")]),e._v(" "),_("li",[e._v("5.kubernetes不负责网络，所以一般是用flannel或者weave。")]),e._v(" "),_("li",[e._v("6.etcd负责服务发现和node信息存储。")])]),e._v(" "),_("p",[_("img",{staticStyle:{width:"1000px","margin-left":"20px"},attrs:{src:v(334)}})]),e._v(" "),_("h2",{attrs:{id:"_02-创建pod的流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_02-创建pod的流程"}},[e._v("#")]),e._v(" 02.创建pod的流程")]),e._v(" "),_("p",[e._v("==一：获取创建请求==")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("1.用户提交创建Pod的请求，可以通过API Server的REST API ，也可用Kubectl命令行工具，支持Json和Yaml两种格式；")])]),e._v(" "),_("li",[_("p",[e._v("2.API Server 处理用户请求，存储Pod数据到Etcd；")])]),e._v(" "),_("li",[_("p",[e._v("3.Schedule通过和 API Server的watch机制，查看到新的pod，尝试为Pod绑定Node；")])])]),e._v(" "),_("p",[e._v("==二：选择Pod主机节点==")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("4.过滤主机：调度器用一组规则过滤掉不符合要求的主机（比如Pod指定了所需要的资源，那么就要过滤掉资源不够的主机）；")])]),e._v(" "),_("li",[_("p",[e._v("5.主机打分：对第一步筛选出的符合要求的主机进行打分，在主机打分阶段，调度器会考虑一些整体优化策略")]),e._v(" "),_("ul",[_("li",[e._v("比如：把一个Replication Controller的副本分布到不同的主机上，使用最低负载的主机等；")])])]),e._v(" "),_("li",[_("p",[e._v("6.选择主机：选择打分最高的主机，进行binding操作，结果存储到Etcd中；")])])]),e._v(" "),_("p",[e._v("==三：调用docker引擎，创建容器==")]),e._v(" "),_("ul",[_("li",[e._v("7.kubelet根据调度结果执行Pod创建操作：\n"),_("ul",[_("li",[e._v("1）绑定成功后，会启动container, docker run,")]),e._v(" "),_("li",[e._v("2）scheduler会调用API Server的API在etcd中创建一个bound pod对象，描述在一个工作节点上绑定运行的所有pod信息。")]),e._v(" "),_("li",[e._v("3）运行在每个工作节点上的kubelet也会定期与etcd同步bound pod信息")]),e._v(" "),_("li",[e._v("4）一旦发现应该在该工作节点上运行的bound pod对象没有更新，则调用Docker API创建并启动pod内的容器。")])])])]),e._v(" "),_("p",[_("img",{staticStyle:{width:"800px","margin-left":"20px"},attrs:{src:v(619)}})])])}),[],!1,null,null,null);t.default=o.exports}}]);